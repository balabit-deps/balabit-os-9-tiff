From 7ec6f53745ab6331382e59373ffd980b38a378f0 Mon Sep 17 00:00:00 2001
From: Lee Howard <faxguy@howardsilvan.com>
Date: Wed, 13 Mar 2024 10:06:21 -0700
Subject: [PATCH] fix tiffcrop issues #552, #550, and #542

---

Index: tiff-4.3.0/tools/tiffcrop.c
===================================================================
--- tiff-4.3.0.orig/tools/tiffcrop.c
+++ tiff-4.3.0/tools/tiffcrop.c
@@ -442,6 +442,7 @@ static uint16_t defcompression = (uint16
 static uint16_t defpredictor = (uint16_t) -1;
 static int    pageNum = 0;
 static int    little_endian = 1;
+static tmsize_t check_buffsize = 0;
 
 /* Functions adapted from tiffcp with additions or significant modifications */
 static int  readContigStripsIntoBuffer   (TIFF*, uint8_t*);
@@ -2071,6 +2072,11 @@ void  process_command_opts (int argc, ch
 		  TIFFError ("Limit for subdivisions, ie rows x columns, exceeded", "%d", MAX_SECTIONS);
 		  exit (EXIT_FAILURE);
                   }
+                if ((page->cols * page->rows) < 1)
+                  {
+                  TIFFError("No subdivisions", "%d", (page->cols * page->rows));
+                  exit(EXIT_FAILURE);
+                  }
                 page->mode |= PAGE_MODE_ROWSCOLS;
 		break;
       case 'U':	/* units for measurements and offsets */
@@ -6298,6 +6304,7 @@ loadImage(TIFF* in, struct image_data *i
     TIFFError("loadImage", "Unable to allocate read buffer");
     return (-1);
     }
+  check_buffsize = buffsize + NUM_BUFF_OVERSIZE_BYTES;
 
   read_buff[buffsize] = 0;
   read_buff[buffsize+1] = 0;
@@ -6928,6 +6935,11 @@ extractImageSection(struct image_data *i
 #ifdef DEVELMODE
         TIFFError ("", "Src offset: %8"PRIu32", Dst offset: %8"PRIu32, src_offset, dst_offset); 
 #endif
+      if (src_offset + full_bytes >= check_buffsize)
+        {
+        printf("Bad input. Preventing reading outside of input buffer.\n");
+        return(-1);
+        }
       _TIFFmemcpy (sect_buff + dst_offset, src_buff + src_offset, full_bytes);
       dst_offset += full_bytes;
       }        
@@ -6962,6 +6974,11 @@ extractImageSection(struct image_data *i
       bytebuff1 = bytebuff2 = 0;
       if (shift1 == 0) /* the region is byte and sample aligned */
         {
+        if (offset1 + full_bytes >= check_buffsize)
+          {
+          printf("Bad input. Preventing reading outside of input buffer.\n");
+          return(-1);
+          }
 	_TIFFmemcpy (sect_buff + dst_offset, src_buff + offset1, full_bytes);
 
 #ifdef DEVELMODE
@@ -6980,6 +6997,11 @@ extractImageSection(struct image_data *i
 
         if (trailing_bits != 0)
           {
+          if (offset1 + full_bytes >= check_buffsize)
+            {
+            printf("Bad input. Preventing reading outside of input buffer.\n");
+            return(-1);
+            }
       /* Only copy higher bits of samples and mask lower bits of not wanted column samples to zero */
 	  bytebuff2 = src_buff[offset1 + full_bytes] & ((unsigned char)255 << (8 - trailing_bits));
           sect_buff[dst_offset] = bytebuff2;
@@ -7006,6 +7028,11 @@ extractImageSection(struct image_data *i
           {
           /* Skip the first shift1 bits and shift the source up by shift1 bits before save to destination.*/
           /* Attention: src_buff size needs to be some bytes larger than image size, because could read behind image here. */
+          if (offset1 + j + 1 >= check_buffsize)
+            {
+            printf("Bad input. Preventing reading outside of input buffer.\n");
+            return(-1);
+            }
           bytebuff1 = src_buff[offset1 + j] & ((unsigned char)255 >> shift1);
           bytebuff2 = src_buff[offset1 + j + 1] & ((unsigned char)255 << (8 - shift1));
           sect_buff[dst_offset + j] = (bytebuff1 << shift1) | (bytebuff2 >> (8 - shift1));
